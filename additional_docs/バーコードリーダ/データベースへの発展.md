## 🚀 発展課題：SQLiteによる本格的なデータベース管理

現在、我々のシステムは出退勤データをCSVファイルに保存している。これは手軽で良い第一歩であるが、データが100件、1000件と増えてくると、様々な問題点が見えてくる。

  * 特定の人の記録だけを抽出したい
  * 特定の日の記録を、時刻順に並べ替えたい
  * 誤って記録の一部を壊してしまうのを防ぎたい

これらの要求に、CSVファイルだけで応えるのは非常に困難である。そこで、**データベース**を導入する。本課題では、Pythonに標準で組み込まれており、手軽に利用できる**SQLite**を使用する。

-----

## 🔍 なぜデータベースが必要か？ (CSV vs. SQLite)

CSVファイルが「データをメモするノート」だとすれば、データベースは「**データを自在に整理・検索できる高機能なファイリングシステム**」である。

| 項目 | CSVファイル | SQLite (データベース) |
| :--- | :--- | :--- |
| **データ検索** | ファイル全体を一行ずつ読む必要があり、非常に低速。 | **高速**。インデックスという索引機能により、膨大なデータからでも瞬時に目的のレコードを発見可能。 |
| **並べ替え** | 事前にプログラム側で全データを読み込み、ソートする必要がある。 | **容易**。SQLという言語の`ORDER BY`句を使い、データベース側で効率的にソートされた結果を取得できる。 |
| **データの一貫性** | どんな文字列でも書き込めてしまうため、日付の書式がバラバラになるなど、データが壊れやすい。 | **高い**。列ごとに「数値のみ」「文字列のみ」といった**データ型**を定義でき、不正なデータの混入を防ぐ。 |
| **拡張性** | Webアプリなど、複数のプログラムから同時に書き込むとファイルが破損するリスクがある。 | **高い**。トランザクション管理により、複数からの同時アクセスでもデータの安全性が保たれる（ファイルロック）。 |

このように、データベースの導入は、システムの**堅牢性**と**拡張性**を飛躍的に向上させる。

-----

## 🏗️ データベースの設計図：「スキーマ」を考える

データベースにデータを保存するには、まず「どのような構造の表を作るか」を定義する必要がある。この**データベースの構造設計**のことを**スキーマ設計**と呼ぶ。これは家を建てる前の設計図に相当し、極めて重要な工程である。

今回の出退勤システムのために、`attendance_logs`という名前のテーブルを設計してみよう。

| カラム名 (列) | データ型 | 説明 |
| :--- | :--- | :--- |
| `id` | `INTEGER PRIMARY KEY AUTOINCREMENT` | 各記録を一位に識別するための番号。自動で連番が振られる**主キー**。 |
| `barcode_id` | `TEXT NOT NULL` | バーコードの番号。`NOT NULL`は空のデータを許可しない制約。 |
| `timestamp` | `TIMESTAMP NOT NULL` | 記録された日時。専用の型で、後から時間計算などが容易になる。 |
| `status` | `TEXT NOT NULL` | 状態。'entry' (入室) または 'exit' (退室) などを記録する。 |

このスキーマをSQL（データベースを操作するための言語）で記述すると、以下のようになる。この`CREATE TABLE`文が、データベースの骨格を定義する。

```sql
CREATE TABLE IF NOT EXISTS attendance_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    barcode_id TEXT NOT NULL,
    timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    status TEXT NOT NULL
);
```

---

## 🏗️ スキーマ設計の深掘り：優れたデータベースの土台を築く

データベースの性能と保守性は、スキーマ設計の品質に大きく依存する。優れた設計は、データを安全に保ち、将来の機能拡張を容易にする。ここでは、テーブルを構成する最も重要な要素である**キー**の役割と、**カラム（列）設計**における注意点について詳述する。

### キー（主キー）の役割と意味

テーブル内の各行（レコード）は、必ず**一意（ユニーク）**でなければならない。もし同じ内容のレコードが複数存在すると、特定のレコードを正確に指定して更新したり、削除したりすることができなくなるからである。

この「レコードの唯一性」を保証するのが**主キー (Primary Key)**の役割である。

**主キーの主な役割**

1.  **一意性の保証 (Uniqueness)**
    主キーとして指定された列には、重複する値を絶対に登録できない。これにより、全てのレコードが区別可能であることがデータベースシステムによって保証される。これは、国民一人一人に割り当てられるマイナンバーや、学生一人一人に与えられる学籍番号と同じ考え方である。

2.  **確実な識別子 (Identifier)**
    各レコードを指し示すための、不変かつ確実な「住所」の役割を果たす。例えば、「2025年8月29日11時44分に記録された、バーコード番号'20250001'のレコード」と指定するより、「IDが5番のレコード」と指定する方が、遥かにシンプルかつ確実である。

**なぜ `INTEGER PRIMARY KEY AUTOINCREMENT` なのか？**

`attendance_logs`テーブルの`id`カラムに指定した`INTEGER PRIMARY KEY AUTOINCREMENT`は、主キーのベストプラクティスである。

* **`INTEGER`**: 数値型は文字列型より高速に比較・検索できる。
* **`PRIMARY KEY`**: この列が主キーであることを宣言する。
* **`AUTOINCREMENT`**: データを`INSERT`（追加）するたびに、データベースが自動で**1, 2, 3...**と連番を振ってくれる。これにより、開発者はIDの採番について一切気にする必要がなくなり、重複のリスクもゼロになる。



---

### カラム設計の注意点

各カラム（列）を設計する際は、「どのようなデータが、どのような形で入るのか」を熟考する必要がある。

#### 1. 適切なデータ型の選択

データ型は、その列に格納できるデータの種類を定義する。適切な型を選ぶことは、データの整合性を保ち、記憶領域を効率化する上で不可欠である。

* **`TEXT` vs `INTEGER`**: バーコード番号は数字の羅列だが、四則演算をするわけではないので`TEXT`（文字列）型が適切である。将来的に「A-001」のような英数字が混ざる可能性にも対応できる。一方、計算が必要な数量などは`INTEGER`（整数）や`REAL`（浮動小数点数）を選ぶべきである。

* **日時の扱い**: 日時を単なる`TEXT`として`"2025-08-29 11:44:38"`のように保存することも可能だが、SQLiteの`TIMESTAMP`型（または`DATETIME`型）を使うべきである。これにより、「特定の日付以降の記録を全て取得する」「2つの時刻の差を計算する」といった、日付や時刻に特化した関数や比較演算子が利用可能になる。

#### 2. 制約 (Constraints) の活用

制約は、データに対するルールを定義し、不正なデータが登録されるのを防ぐ門番の役割を果たす。

* **`NOT NULL`**: 「この列は、絶対に空（NULL）であってはならない」という制約である。例えば、`barcode_id`や`timestamp`は記録として必須の情報であるため、`NOT NULL`を指定することで、これらの情報が欠落した不良データが生まれるのを防ぐ。

* **`DEFAULT`**: もしデータが指定されなかった場合に、自動で設定される初期値を定義する。`timestamp`カラムに`DEFAULT CURRENT_TIMESTAMP`と指定しているのは、「もし日時の指定なくデータがINSERTされたら、その瞬間の現在日時を自動で記録する」という意味である。これにより、プログラム側のタイムスタンプ付与処理をデータベースに肩代わりさせることも可能になる。

優れたスキーマ設計とは、単にデータを格納する箱を用意するだけでなく、**データ自身が持つべきルールや制約をデータベースの力で強制し、データの健全性を将来にわたって守る**ための設計なのである。
-----

##  🕸️ Webシステムへの発展 (Flaskの活用)

データベースを導入した最大のメリットの一つが、Webアプリケーションとの連携である。Pythonの軽量なWebフレームワークである**Flask**を使えば、記録された出退勤ログをブラウザで閲覧するシステムを驚くほど簡単に構築できる。

**システムの動作フロー**

1.  **ブラウザ**: ユーザーがPCやスマートフォンのブラウザで特定のURL (例: `http://raspberrypi.local/logs`) にアクセスする。
2.  **Flaskアプリ**: Raspberry Pi上で動作しているFlaskアプリが、そのリクエストを受け取る。
3.  **データベース問合せ**: FlaskアプリはSQLiteデータベースに接続し、「`SELECT * FROM attendance_logs ORDER BY timestamp DESC` (全ログを時刻の新しい順に取得せよ)」のようなSQLクエリを実行する。
4.  **HTML生成**: データベースから受け取った結果を、HTMLのテーブル形式のテンプレートに埋め込む。
5.  **ブラウザ**: Flaskアプリが生成したHTMLをブラウザに送信し、ユーザーはリアルタイムの出退勤状況を綺麗な表で確認できる。

CSVファイルでは実現が難しかった、**動的でインタラクティブなデータ表示**が、データベースとWebフレームワークの組み合わせによって初めて可能になるのである。この経験は、より高度なWebシステム開発への第一歩となるだろう。